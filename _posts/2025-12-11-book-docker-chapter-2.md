---
title: "[도커 교과서] 2장 도커의 기본적인 사용법"
date: 2025-12-11 14:00:00 +0900
categories: [Study, Docker]
tags: [docker]
---

# 2장 도커의 기본적인 사용법

## 학습 목표

- 컨테이너를 실행하는 다양한 방법을 알 수 있다.
- 도커의 컨테이너가 무엇인지 알 수 있다.
- 컨테이너가 애플리케이션을 경량으로 실행할 수 있는 이유를 알 수 있다.

## 2.1 컨테이너로 Hello World 실행하기

```bash
docker container run {허브에 업로드되어있는 도커 이미지}
```

해당 명령은 컨테이너로 애플리케이션을 실행하라는 도커 명령어이다.

도커를 사용하는 워크플로의 핵심은 

내가 컨테이너에 실행시키려는 애플리케이션을 패키징**(빌드)** 

다른 사람이 해당 패키지를 사용할 수 있도록 공유**(공유)**, 

이 패키지를 내려 받은 사람이 컨테이너를 통해 애플리케이션을 실행**(배포)**

## 2.2 컨테이너란 무엇인가?

![image.png](https://thebook.io/img/080258/050_2.jpg)

컨테이너 안에는 애플리케이션, 애플리케이션을 실행할 컴퓨터(IP 주소, 컴퓨터 이름, 디스크 드라이브)가 존재

**호스트명, IP 주소, 파일 시스템**은 도커가 만들어낸 **가상 리소스(격리)**

컨테이너는 서로 독립적인 환경을 갖지만 해당 컨테이너가 실행되는 컴퓨터의 **CPU와 메모리, 운영체제를 공유
(밀집)**

### 가상 머신 vs 컨테이너

![image.png](https://thebook.io/img/080258/051.jpg)

가상 머신은 호스트 컴퓨터의 운영체제를 공유하지 않고 **별도의 운영체제를 갖음(격리)**

가상 머신 은 서로 독립적인 환경을 갖지만 해당 가상 머신이 실행되는 컴퓨터의 **CPU와 메모리를 공유**

**하지만, 애플리케이션이 사용해야 할 CPU와 메모리 자원의 상당량을 가상 머신의 운영체제가 사용
→ 밀집성이 컨테이너 방식보다 떨어짐**

컨테이너는 운영체제, CPU, 메모리를 공유하기 때문에 가상 머신보다 리소스가 경감될 뿐만 아니라 실행이 빠름
**→ 매우 효율적**

## 2.3 컨테이너를 원격 컴퓨터처럼 사용하기

```bash
docker container run --interactive --tty {이미지}
```

실행된 컨테이너에 원격 컴퓨터 접속하듯 터미널에 접속하는 명령어

**—interactive: 컨테이너에 접속된 상태**

**—tty: 터미널 세션을 통해 컨테이너를 조작**

**실행중인 컨테이너에 대한 정보를 확인하는 명령어**

```bash
# 현재 실행 중인 모든 컨테이너에 대한 정보 확인 (ID, IMAGE, COMMAND, CREATED, STATUS)
docker container ls

# 특정 컨테이너에 대한 정보 확인
docker container top {containerID}

# 특정 컨테이너에 대한 수집된 모든 로그 확인
docker container logs {containerID}

# 특정 컨테이너에 대한 상세한 정보 확인
docker container inspect {continerID}
```

해당 명령들은 컨테이너를 다루거나 애플리케이션에 일어난 문제를 찾고 해결하기 위해 일상적으로 사용

## 2.4 컨테이너를 사용해 웹 사이트 호스팅하기

```bash
docker container ls --all
```

해당 명령을 통해 **상태와 상관없이** 모든 컨테이너의 목록을 확인

컨테이너는 애플리케이션이 실행중이어야 컨테이너도 실행중인 상태가 됨

종료된 컨테이너는 CPU 자원이나 메모리를 사용하지 않음

컨테이너가 종료돼도 컨테이너는 사라지지 않고 호스트 컴퓨터의 디스크 공간을 계속 점유

### 컨테이너를 백그라운드에서 계속 동작하게 하려면?

```bash
docker container run --detach --publish 8080:80 {웹 사이트 호스팅하는 이미지}
```

해당 명령을 통해 컨테이너가 **백그라운드에서 동작**하면서 **네트워크를 주시**

**—detach: 컨테이너를 백그라운드에서 실행하며 컨테이너 ID를 출력**

**—publish: 컨테이너의 포트를 호스트 컴퓨터에 공개**

동작 과정

1. 도커 설치 후, 호스트 컴퓨터의 네트워크 계층에 도커가 추가 됨
2. 네트워크 트래픽을 모두 도커가 가로챔
3. 호스트 컴퓨터의 8080 포트 트래픽을 공개한 컨테이너 포트인 80포트로 전달
**—publish 플래그를 통해 80포트를 공개했기 때문에 해당 컨테이너로 트래픽을 전달할 수 있음**

```bash
# 실행 중인 컨테이너의 상태를 확인(CPU, 메모리, 네트워크, 디스크 사용량)
docker container stats {containerID} 

# 특정 컨테이너를 삭제
docker container rm {containerID}

# 실행중인 특정 컨테이너를 삭제
docker container rm --force {containerID}

# 모든 컨테이너를 삭제
docker container rm --force $(docker container ls --all --quiet)
```

## 2.5 도커가 컨테이너를 실행하는 원리

![image.png](https://thebook.io/img/080258/061.jpg)

1. **도커 엔진**
    - **도커의 관리 기능**을 맡는 컴포넌트
    - **로컬 이미지 캐시를 담당**, 새로운 이미지가 필요하면 이미지를 내려받고 기존 이미지가 존재하면 해당 이미지를 사용
    - 호스트 운영체제와 함께 **도커 리소스를 만드는 일**을 담당
    - **항상 동작하는 백그라운드 프로세스**
    - **도커 API를 통해** 해당 기능을 수행
2. **도커 API**
    - 표준 HTTP기반 REST API
    - 도커 엔진과 상호 작용할 수 있는 유일한 방법
    - 설정을 통해 외부에서 API의 접근 허용 범위를 제한
3. **도커 CLI**
    - docker 명령을 사용할 때 도커 API를 호출

## 2.6 연습 문제: 컨테이너 파일 시스템 다루기

```bash
# docker cp를 통해서 컨테이너(ID:75) 내부의 index.html을 로컬로 복사
docker container cp 75:/usr/local/apache2/htdocs/index.html .

# 로컬에서 index.html을 수정
nano index.html

# 로컬에서 컨테이너(ID:75)로 수정된 index.html 파일 복사/덮어쓰기
docker cp index.html 75:/usr/local/apache2/htdocs/index.html
```

![image.png](2%EC%9E%A5%20%EB%8F%84%EC%BB%A4%EC%9D%98%20%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8%20%EC%82%AC%EC%9A%A9%EB%B2%95/image%203.png)